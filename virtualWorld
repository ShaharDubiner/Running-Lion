//**************************************************************************************************************************************************************//
// Javascript assignment to draw a textured 3D virtual world with a movable camera.
//**************************************************************************************************************************************************************//
// Vertex shader program.
const VSHADER_SOURCE =
	'attribute vec4 a_Position;\n' +
	'attribute vec4 a_Normal;\n' +
	
	'uniform mat4 u_MvpMatrix;\n' +
	'uniform mat4 u_NormalMatrix;\n' +
	
	'uniform vec3 u_LightDirection;\n' +
	'uniform vec3 u_LightColor;\n' +
	'uniform vec3 u_AmbientLight;\n' +
	'attribute vec4 a_Color;\n' +
	'varying vec4 v_Color;\n' +
	
	'uniform bool u_Textured;\n' +
	'attribute vec2 a_TexCoord;\n' +
	'varying vec2 v_TexCoord;\n' +
	'void main(){\n' +
	// Apply matrix to base position.
	'    gl_Position = u_MvpMatrix * a_Position;\n' +
	// Recalculate the normal based on the model matrix and normalize it.
	'    vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal));\n' +
	// The dot product of the light direction and the normal
	'    float nDotL = max(dot(u_LightDirection, normal), 0.0);\n' +
	// Calculate total lighting vector.
	'    vec3 lighting = u_AmbientLight + u_LightColor*nDotL;\n' +
	// Send color data to fragment shader.
	'  	 v_Color = vec4(u_Textured ? lighting:lighting*a_Color.rgb, u_Textured ? 0.0:a_Color.a);\n' +
	// Send texture data to fragment shader.
	'    if(u_Textured){ v_TexCoord = a_TexCoord; }\n' +
	'}\n';
// Fragment shader program.
const FSHADER_SOURCE =
	'#ifdef GL_ES\n' +
	'precision mediump float;\n' +
	'#endif\n' +
	'uniform bool u_Textured;\n' +
	'uniform sampler2D u_Sampler;\n' +
	
	'varying vec4 v_Color;\n' +
	'varying vec2 v_TexCoord;\n' +
	'void main(){\n' +
	'    if(u_Textured){\n' +
	'        vec4 texelColor = texture2D(u_Sampler, v_TexCoord);\n' +
	'  	     gl_FragColor = vec4(texelColor.rgb*v_Color.rgb, texelColor.a);\n' +
	'    }\n' +
	'    else{ gl_FragColor = v_Color; }\n' +
	'}\n';
//**************************************************************************************************************************************************************//
// Class definition for the viewpoint camera.
function Camera(_id, _loc, _vel, _target, _tVel, _renderMin, _renderMax){
	this.id = _id;										// Text ID.
	this.loc = _loc; this.vel = _vel;					// Camera position and its change per update tick.
	this.target = _target; this.tVel = _tVel;			// Camera focus point and its change per update tick.
	this.renderMin = _renderMin;						// Minimum rendering distance.
	this.renderMax = _renderMax;						// Maximum rendering distance.
	this.up = [0.0, 1.0, 0.0];							// Vector declaring which way is up relative to the camera.
	this.aRatio = canvas.width/canvas.height;			// Aspect ratio of the frustum.
	// Update this camera object for the given number of animation ticks.
	this.update = function(ticks){
		this.loc[0] += ticks*this.vel[0];
		this.loc[1] += ticks*this.vel[1];
		this.loc[2] += ticks*this.vel[2];
		
		this.target[0] += ticks*this.tVel[0];
		this.target[1] += ticks*this.tVel[1];
		this.target[2] += ticks*this.tVel[2];
		// 1: Angle between the upper and lower sides of the frustum.
		// 2: Aspect ratio of the frustum.
		// 3: Distance to the nearest depth clipping plane. Must be positive.
		// 3: Distance to the farthest depth clipping plane. Must be positive.
		viewProjMatrix.setPerspective(60.0, this.aRatio, this.renderMin, this.renderMax);
		// 1, 2, 3: Camera location.
		// 4, 5, 6: Location the camera is looking at.
		// 7, 8, 9: Vector declaring which way is up relative to the camera.
		viewProjMatrix.lookAt(this.loc[0], this.loc[1], this.loc[2],
							  this.target[0], this.target[1], this.target[2],
							  this.up[0], this.up[1], this.up[2]);
	}
	// Move this camera object according to the current perspective's vectors by the given amounts.
	this.move = function(x, y, z){
		var view = viewProjMatrix.elements;
		// Left/Right
		if(x != 0){
			this.loc[0] += x*view[0]; this.loc[1] += x*view[4]; this.loc[2] += x*view[8];
			this.target[0] += x*view[0]; this.target[1] += x*view[4]; this.target[2] += x*view[8];
		}
		// Up/Down
		if(y != 0){
			this.loc[0] += y*view[1]; this.loc[1] += y*view[5]; this.loc[2] += y*view[9];
			this.target[0] += y*view[1]; this.target[1] += y*view[5]; this.target[2] += y*view[9];
		}
		// Forward/Backward
		if(z != 0){
			this.loc[0] += z*view[2]; this.loc[1] += z*view[6]; this.loc[2] += z*view[10];
			this.target[0] += z*view[2]; this.target[1] += z*view[6]; this.target[2] += z*view[10];
		}
	}
	// Turn this camera object according to the current perspective's vectors by the given amounts.
	this.turn = function(x, y){
		var view = viewProjMatrix.elements;
		// Left/Right
		if(x != 0){
			this.target[0] += x*view[0]; this.target[1] += x*view[4]; this.target[2] += x*view[8];
		}
		// Up/Down
		if(y != 0){
			this.target[0] -= y*view[1]; this.target[1] -= y*view[5]; this.target[2] -= y*view[9];
		}
	}
}
//**************************************************************************************************************************************************************//
// Class definition for a 3D shape to be drawn.
function Shape(_id, _vertexBuffer, _normalsBuffer, _indicesBuffer, _colorBuffer,
			_size, _loc, _rotations){
	this.id = _id;										// Text ID.
	this.vertexBuffer = _vertexBuffer;					// WebGL buffer containing shape vertices.
	this.normalsBuffer = _normalsBuffer;				// WebGL buffer containing shape normals.
	this.indicesBuffer = _indicesBuffer;				// WebGL buffer indicating which vertices triangles are drawn between.
	this.colorBuffer = _colorBuffer;					// WebGL buffer containing vertex colors.
	this.texture = null;								// Optional texture data to override color buffer.
	this.textureMap = null;								// Mapping of the texture to shape vertices, if it exists.
	
	this.size = _size; this.growth = [0.0, 0.0, 0.0];	// Scaling matrix and its change per update tick.
	this.loc = _loc; this.vel = [0.0, 0.0, 0.0];		// Translation matrix and its change per update tick.
	this.rotations = _rotations;						// Bundled rotation matrices, their change per update tick, and their center of rotation.
	this.branches = [];									// Array of shapes branching off from this one. They will remain connected and follow it as it moves.
	this.setTexture = function(_texture, _textureMap){
		this.texture = _texture;
		this.textureMap = _textureMap;
	}
	// Update this shape (and all branching shapes) for the given number of animation ticks.
	this.update = function(ticks){
		this.size[0] += ticks*this.growth[0];
		this.size[1] += ticks*this.growth[1];
		this.size[2] += ticks*this.growth[2];
		
		this.loc[0] += ticks*this.vel[0];
		this.loc[1] += ticks*this.vel[1];
		this.loc[2] += ticks*this.vel[2];
		
		for(var i = 0; i < this.rotations.length; ++i){
			var rotate = this.rotations[i];
			rotate[0] = (rotate[0] + ticks*rotate[4])%360;
		}
		
		for(var i = 0; i < this.branches.length; ++i){
			this.branches[i].update(ticks);
		}
	}
	// Draw this shape (and all branching shapes).
	this.draw = function(){
		// Apply location and rotation transforms to brush.
		brush.translate(this.loc[0], this.loc[1], this.loc[2]);
		if(this.rotations.length > 0){
			for(var i = 0; i < this.rotations.length; ++i){
				var rotate = this.rotations[i];
				brush.translate(rotate[5][0], rotate[5][1], rotate[5][2]);
				brush.rotate(rotate[0], rotate[1], rotate[2], rotate[3]);
				brush.translate(-rotate[5][0], -rotate[5][1], -rotate[5][2]);
			}
		}
		
		// Assign vertex buffer to WebGL.
		if(this.vertexBuffer != prevVertices){
			// Bind the WebGL buffer object to this shape's vertex buffer.
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
			// Assign the vertex buffer object to the vertex shader's position variable.
			// 1: Shader attribute to assign to.
			// 2: Number of components per vertex (1-4).
			// 3: Datatype enum. [gl.BYTE, gl.SHORT, gl.UNSIGNED_BYTE, gl.UNSIGNED_SHORT, gl.FLOAT, gl.HALF_FLOAT]
			// 4: Normalization boolean (forces non-float data to a -1 to 1 range if enabled).
			// 5: Data stride. Specifies the offset in bytes (0-255) between the beginning of consecutive vertex attributes.
			// 6: Offset in bytes of the first element in the vertex attribute array. Must be a multiple of the byte length of the datatype.
			gl.vertexAttribPointer(a_Position, this.vertexBuffer.num, this.vertexBuffer.type, false, 0, 0);
			// Enable the above assignment.
			gl.enableVertexAttribArray(a_Position);
			prevVertices = this.vertexBuffer;
		}
		// Textures.
		if(this.texture != null){
			if(this.texture != prevColors){
				gl.bindBuffer(gl.ARRAY_BUFFER, this.textureMap);
				gl.vertexAttribPointer(a_TexCoord, this.textureMap.num, this.textureMap.type, false, 0, 0);
				gl.enableVertexAttribArray(a_TexCoord);
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, this.texture);
				gl.uniform1i(u_Sampler, 0);
				gl.uniform1i(u_Textured, true);
				prevColors = this.texture;
			}
		}
		// Colors.
		else if(this.colorBuffer != prevColors){
			gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
			gl.vertexAttribPointer(a_Color, this.colorBuffer.num, this.colorBuffer.type, false, 0, 0);
			gl.enableVertexAttribArray(a_Color);
			gl.uniform1i(u_Textured, false);
			prevColors = this.colorBuffer;
		}
		// Normals.
		if(this.normalsBuffer != prevNormals){
			gl.bindBuffer(gl.ARRAY_BUFFER, this.normalsBuffer);
			gl.vertexAttribPointer(a_Normal, this.normalsBuffer.num, this.normalsBuffer.type, false, 0, 0);
			gl.enableVertexAttribArray(a_Normal);
			prevNormals = this.normalsBuffer;
		}
		// Assign vertex indices to the WebGL element array buffer object. Informs which vertices triangles are drawn between.
		if(this.indicesBuffer != prevIndices){
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
			prevIndices = this.indicesBuffer;
		}

		// Calculate the model view projection matrix and pass it to u_MvpMatrix.
		g_mvpMatrix.set(viewProjMatrix);
		// Apply scaling transform to shape.
		g_mvpMatrix.multiply(brush);
		g_mvpMatrix.scale(this.size[0], this.size[1], this.size[2]);
		gl.uniformMatrix4fv(u_MvpMatrix, false, g_mvpMatrix.elements);
		// Calculate the matrix for normal and pass it to u_NormalMatrix.
		brushNormal.setInverseOf(brush);
		brushNormal.transpose();
		gl.uniformMatrix4fv(u_NormalMatrix, false, brushNormal.elements);
		// Draw this shape.
		gl.drawElements(gl.TRIANGLES, this.indicesBuffer.len, gl.UNSIGNED_BYTE, 0);
		// Draw shapes branching from this one.
		brushStates.push(new Matrix4(brush));
		for(var i = 0; i < this.branches.length; ++i){
			brush.set(brushStates[brushStates.length-1]);
			this.branches[i].draw();
		}
		brush = brushStates.pop();
	}
}
//**************************************************************************************************************************************************************//
// Global variables.
var gl = null;
var canvas = null;
var time = Date.now(), lastTime = time, fps = 60;
var prevVertices = null, prevColors = null, prevNormals = null, prevIndices = null;

var a_Position = null, a_Normal = null;
var u_MvpMatrix = null, u_NormalMatrix = null;
var u_LightDirection = null, u_LightColor = null, u_AmbientLight = null, a_Color = null;
var a_TexCoord = null, u_Textured = null, u_Sampler = null;
var viewProjMatrix = null;

// Textures.
var textures = [];
// Universal cube properties.
var cubeVertices = null, cubeNormals = null, cubeIndices = null, cubeTextureMap = null;
var cubeColors = [];
// Root shapes which do not branch off from others.
var shapes = [];
// Specific shapes to keep track of.
var body1 = null, body2 = null, neck = null, head = null, snoutBottom = null;
var frontLegL1 = null, frontLegL2 = null, frontLegL3 = null;
var frontLegR1 = null, frontLegR2 = null, frontLegR3 = null;
var backLegL1 = null, backLegL2 = null, backLegL3 = null, backLegL4 = null;
var backLegR1 = null, backLegR2 = null, backLegR3 = null, backLegR4 = null;
var tail1 = null, tail2 = null, tail3 = null, tail4 = null, tail5 = null, tail6 = null, tail7 = null;

// Camera object.
var camera = null;
// Current transformation matrices.
var brush = new Matrix4(), brushNormal = new Matrix4(), g_mvpMatrix = new Matrix4();
// Transformation matrix history.
var brushStates = [];

// Animation frame timers.
var timer = 20, turnTicks = 40;
// Mouse tracking variables.
var mouseDown = false;
var mouseDisplace = [0, 0], mouseLocPress = [0, 0];
// Constants.
const RADIAN_CONVERT = Math.PI/180.0;
const MOVE_SPEED = 1.0, TURN_SPEED = 0.5, TURN_SPEED_MOUSE = 0.001, TURN_BUFFER = 10.0;
const LION_SPEED = 0.5, LION_TURN_SPEED = 0.5;
//**************************************************************************************************************************************************************//
function onLoad(){
	// Retrieve <canvas> element.
	canvas = document.getElementById('canvas');
	// Get the rendering context for WebGL with alpha enabled.
	gl = canvas.getContext("webgl", {premultipliedAlpha: false});
	if(!gl){ console.error('Failed to get the rendering context for WebGL!'); return; }
	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	// Initialize shaders.
	if(!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)){ console.error('Failed to intialize shaders.'); return; }
	
	// Get the storage location of shader defined variables.
	a_Position = gl.getAttribLocation(gl.program, 'a_Position');
	if(a_Position < 0){ console.error('Failed to get the storage location of a_Position.'); return; }
	a_Normal = gl.getAttribLocation(gl.program, 'a_Normal');
	if(a_Normal < 0){ console.error('Failed to get the storage location of a_Normal.'); return; }
	
	u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');
	if(!u_MvpMatrix){ console.error('Failed to get the storage location of u_MvpMatrix.'); return; }
	u_NormalMatrix = gl.getUniformLocation(gl.program, 'u_NormalMatrix');
	if(!u_NormalMatrix){ console.error('Failed to get the storage location of u_NormalMatrix.'); return; }
	
	u_LightDirection = gl.getUniformLocation(gl.program, 'u_LightDirection');
	if(!u_LightDirection){ console.error('Failed to get the storage location of u_LightDirection.'); return; }
	u_LightColor = gl.getUniformLocation(gl.program, 'u_LightColor');
	if(!u_LightColor){ console.error('Failed to get the storage location of u_LightColor.'); return; }
	u_AmbientLight = gl.getUniformLocation(gl.program, 'u_AmbientLight');
	if(!u_AmbientLight){ console.error('Failed to get the storage location of u_AmbientLight.'); return; }
	a_Color = gl.getAttribLocation(gl.program, 'a_Color');
	if(a_Color < 0){ console.error('Failed to get the storage location of a_Color.'); return; }
	
	a_TexCoord = gl.getAttribLocation(gl.program, 'a_TexCoord');
	if(a_TexCoord < 0){ console.error('Failed to get the storage location of a_TexCoord.'); return; }
	u_Textured = gl.getUniformLocation(gl.program, 'u_Textured');
	if(!u_Textured){ console.error('Failed to get the storage location of u_Textured.'); return; }
	u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
	if(!u_Sampler){ console.error('Failed to get the storage location of u_Sampler.'); return; }
	
	// Create the view projection matrix.
	viewProjMatrix = new Matrix4();
	// Camera(ID, loc, vel, target, tVel, renderMin, renderMax)
	camera = new Camera("PlayerView", [20.0, 10.0, 30.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0],
			1.0, 1000.0);
	camera.update(0);
	
	// Set lighting.
	gl.uniform3f(u_LightColor, 1.0, 1.0, 1.0);
	gl.uniform3f(u_LightDirection, 0.2, 0.5, 0.7);
	gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2);
	
	defineShapeTypes();
	loadTextures();
	initShapes();
	
	// Register the function to be called while a key is pressed.
	document.onkeydown = function(e){ keyDown(e); };
	// Register function to be called on mouse press.
	canvas.onmousedown = function(e){ mousePress(e); };
	// Register function to be called on mouse release.
	document.onmouseup = function(e){ mouseRelease(e); };
	// If page focus is lost, release mouse press.
	document.onblur = function(e){ mouseRelease(e); };
	// Register function to be called on mouse move.
	document.onmousemove = function(e){ mouseMove(e); };
	
	// Specify the color for clearing the canvas.
	gl.clearColor(0.0, 0.0, 0.0, 1.0); clear();
	// Enable 3D.
	gl.enable(gl.DEPTH_TEST);
	
	requestAnimationFrame(update);
	draw();
}
// Load textures to be used.
function loadTextures(){
	textures.sky = loadTexture("sky.jpg");
	textures.rock = loadTexture("rock.jpg");
}
// Create shape archtypes to be used.
function defineShapeTypes(){
	// Cube vertices.
	cubeVertices = getArrayBuffer(cuboidVertices(1, 1, 1), 3, gl.FLOAT);
	// Cuboid normals.
	const normals = new Float32Array([
		 0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0, // v0-v1-v2-v3 front
		 1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 0.0, 0.0, // v0-v3-v4-v5 right
		 0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0,  0.0, 1.0, 0.0, // v0-v5-v6-v1 up
		-1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // v1-v6-v7-v2 left
		 0.0,-1.0, 0.0,  0.0,-1.0, 0.0,  0.0,-1.0, 0.0,  0.0,-1.0, 0.0, // v7-v4-v3-v2 down
		 0.0, 0.0,-1.0,  0.0, 0.0,-1.0,  0.0, 0.0,-1.0,  0.0, 0.0,-1.0  // v4-v7-v6-v5 back
	]);
	cubeNormals = getArrayBuffer(normals, 3, gl.FLOAT);
	// Cuboid vertex indices.
	const indices = new Uint8Array([
		 0, 1, 2,   0, 2, 3, // front
		 4, 5, 6,   4, 6, 7, // right
		 8, 9,10,   8,10,11, // up
		12,13,14,  12,14,15, // left
		16,17,18,  16,18,19, // down
		20,21,22,  20,22,23  // back
	]);
	cubeIndices = gl.createBuffer();
	if(!cubeIndices){ console.error('Failed to create buffer object.'); return null; }
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndices);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
	cubeIndices.len = indices.length;
	// Cube texture mapping. Texture dimensions are normalized when used by WebGL.
	const textureMap = new Float32Array([
		 0.0, 0.0,  0.0, 1.0,  1.0, 1.0,  1.0, 0.0, // front
		 0.0, 0.0,  0.0, 1.0,  1.0, 1.0,  1.0, 0.0, // right
		 0.0, 0.0,  0.0, 1.0,  1.0, 1.0,  1.0, 0.0, // up
		 0.0, 0.0,  0.0, 1.0,  1.0, 1.0,  1.0, 0.0, // left
		 0.0, 0.0,  0.0, 1.0,  1.0, 1.0,  1.0, 0.0, // down
		 0.0, 0.0,  0.0, 1.0,  1.0, 1.0,  1.0, 0.0  // back
	]);
	cubeTextureMap = getArrayBuffer(textureMap, 2, gl.FLOAT);
	// Cuboid color pallete.
	cubeColors.ground = getArrayBuffer(vertexColors(24, 0.4, 0.6, 0.2, 1.0), 4, gl.FLOAT);
	cubeColors.lionFur = getArrayBuffer(vertexColors(24, 0.75, 0.55, 0.0, 1.0), 4, gl.FLOAT);
	cubeColors.lionFuzz = getArrayBuffer(vertexColors(24, 0.65, 0.45, 0.0, 1.0), 4, gl.FLOAT);
	cubeColors.lionMane = getArrayBuffer(vertexColors(24, 0.55, 0.35, 0.0, 1.0), 4, gl.FLOAT);
	cubeColors.lionTailTip = getArrayBuffer(vertexColors(24, 0.35, 0.2, 0.0, 1.0), 4, gl.FLOAT);
	cubeColors.lionSnoutTop = getArrayBuffer(vertexColors(24, 0.8, 0.6, 0.4, 1.0), 4, gl.FLOAT);
	cubeColors.lionSnoutBottom = getArrayBuffer(vertexColors(24, 0.95, 0.8, 0.7, 1.0), 4, gl.FLOAT);
	cubeColors.lionTongue = getArrayBuffer(vertexColors(24, 1.0, 0.1, 0.1, 1.0), 4, gl.FLOAT);
	cubeColors.lionNose = getArrayBuffer(vertexColors(24, 0.1, 0.1, 0.1, 1.0), 4, gl.FLOAT);
	cubeColors.lionEyes = getArrayBuffer(vertexColors(24, 0.1, 0.1, 0.1, 1.0), 4, gl.FLOAT);
}
// Create starting shapes and set up vertex buffering and normals.
function initShapes(){
	// Shape(ID, vertexBuffer, normalsBuffer, indicesBuffer, colorBuffer, size, loc, [rotations])
	/*var newShape = new Shape("core", cubeVertices, cubeNormals, cubeIndices, getArrayBuffer(vertexColors(24, 0.6, 0.6, 0.6, 1.0), 4, gl.FLOAT),
			[10.0, 10.0, 2.0], [0.0, 0.0, 0.0], [[0.0, 1.0, 0.0, 0.0, 0.0, [0.0, 0.0, 0.0]]]);
	shapes.push(newShape);*/
	initShapesWorld();
	initShapesLion();
}
function initShapesWorld(){
	var sky = new Shape("skybox", cubeVertices, cubeNormals, cubeIndices, null,
			[500.0, 500.0, 500.0], [0.0, 0.0, 0.0], []);
	sky.setTexture(textures.sky, cubeTextureMap);
	shapes.push(sky);
	var ground = new Shape("ground", cubeVertices, cubeNormals, cubeIndices, cubeColors.ground,
			[320.0, 2.0, 320.0], [0.0, -10.0, 0.0], [[35.0, 0.0, 1.0, 0.0, 0.0, [0.0, 0.0, 0.0]]]);
	shapes.push(ground);
	var wallMap = [[4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 3,  2, 3, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 2, 0, 1,  0, 2, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 4, 0, 1,  0, 3, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 2, 0, 0,  0, 3, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  2, 3, 3, 3, 3,  0, 3, 4, 4, 4,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   
				   [4, 0, 0, 0, 0,  3, 0, 0, 0, 0,  0, 3, 4, 4, 4,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 1, 2, 3, 2,  2, 0, 1, 3, 2,  2, 3, 4, 4, 4,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 2,  1, 4, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 3,  0, 3, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 4,  1, 2, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   
				   [4, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 4],
				   [4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4, 4, 4, 4,  4, 4]];
	var halfX = wallMap.length/2, halfY = wallMap[0].length/2;
	for(var i = 0; i < wallMap.length; ++i){
		for(var j = 0; j < wallMap[i].length; ++j){
			var prevBlock = ground;
			for(var n = 0; n < wallMap[i][j]; ++n){
				var block = new Shape("block", cubeVertices, cubeNormals, cubeIndices, null,
									  [10.0, 10.0, 10.0], (prevBlock == ground) ? [10.0*(i-halfX), 5.0, 10.0*(j-halfY)]:[0.0, 10.0, 0.0], []);
				block.setTexture(textures.rock, cubeTextureMap);
				prevBlock.branches.push(block);
				prevBlock = block;
			}
		}
	}
}
function initShapesLion(){
	body1 = new Shape("body1", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[8.0, 8.0, 10.0], [35.0, 5.0, 0.0], [[0.0, 0.0, 0.5, 0.0, 0.0, [0.0, 0.0, 0.0]], [0.0, 1.0, 0.0, 0.0, 0.45, [0.0, 0.0, 0.0]]]);
	shapes.push(body1);
	body2 = new Shape("body2", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[6.0, 6.0, 10.0], [0.0, -0.3, -8.0], [[0.0, -1.0, 0.0, 0.0, 0.45, [0.0, 0.3, 0.0]]]);
	body1.branches.push(body2);

	neck = new Shape("neck", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[3.5, 3.5, 5.0], [0.0, 2.0, 5.0], [[0.0, -1.0, 0.0, 0.0, 0.3, [0.0, 0.0, 0.0]]]);
	body1.branches.push(neck);
	head = new Shape("head", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[5.0, 5.0, 4.0], [0.0, 0.25, 3.0], [[0.0, -1.0, 0.0, 0.0, 0.3, [0.0, 0.0, 0.0]]]);
	neck.branches.push(head);
	snoutTop = new Shape("snoutTop", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionSnoutTop,
			[2.5, 1.0, 2.5], [0.0, -1.1, 3.0], []);
	head.branches.push(snoutTop);
	snoutBottom = new Shape("snoutBottom", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionSnoutBottom,
			[2.5, 0.75, 2.5], [0.0, -2.0, 3.0], [[20.0, 1.0, 0.0, 0.0, 0.5, [0.0, 0.0, -0.5]]]);
	head.branches.push(snoutBottom);
	
	tongue = new Shape("tongue", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionTongue,
			[1.5, 0.5, 1.5], [0.0, 0.3, 0.0], []);
	snoutBottom.branches.push(tongue);
	nose = new Shape("nose", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionNose,
			[1.25, 0.5, 0.75], [0.0, 0.45, 1.0], []);
	snoutTop.branches.push(nose);
	leftEye = new Shape("leftEye", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionEyes,
			[0.5, 0.5, 0.5], [1.1, 0.75, 2.0], []);
	head.branches.push(leftEye);
	rightEye = new Shape("rightEye", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionEyes,
			[0.5, 0.5, 0.5], [-1.1, 0.75, 2.0], []);
	head.branches.push(rightEye);
	leftEar1 = new Shape("leftEar1", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[0.9, 1.0, 0.5], [1.75, 2.5, 1.3], []);
	head.branches.push(leftEar1);
	leftEar2 = new Shape("leftEar2", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[0.6, 0.5, 0.4], [0.0, 0.75, 0.0], []);
	leftEar1.branches.push(leftEar2);
	rightEar1 = new Shape("rightEar1", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[0.9, 1.0, 0.5], [-1.75, 2.5, 1.3], []);
	head.branches.push(rightEar1);
	rightEar2 = new Shape("rightEar2", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[0.6, 0.5, 0.4], [0.0, 0.75, 0.0], []);
	rightEar1.branches.push(rightEar2);
	mane = new Shape("mane", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionMane,
			[8.0, 8.0, 3.0], [0.0, -0.25, -0.5], []);
	head.branches.push(mane);
	
	frontLegL1 = new Shape("frontLegL1", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[2.0, 5.0, 2.0], [3.5, -5.0, 3.5], [[0.0, 1.0, 0.0, 0.0, 2.5, [0.0, 1.0, 0.0]]]);
	body1.branches.push(frontLegL1);
	frontLegL2 = new Shape("frontLegL2", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.75, 5.0, 1.75], [0.0, -4.0, 0.2], [[0.0, 1.0, 0.0, 0.0, 1.25, [0.0, 1.0, -0.2]]]);
	frontLegL1.branches.push(frontLegL2);
	frontLegL3 = new Shape("frontLegL3", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFuzz,
			[1.75, 2.0, 1.75], [0.0, -3.0, 0.1], [[0.0, 1.0, 0.0, 0.0, 1.25, [0.0, 0.0, 0.0]]]);
	frontLegL2.branches.push(frontLegL3);

	frontLegR1 = new Shape("frontLegR1", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[2.0, 5.0, 2.0], [-3.5, -5.0, 3.5], [[0.0, 1.0, 0.0, 0.0, 2.5, [0.0, 1.0, 0.0]]]);
	body1.branches.push(frontLegR1);
	frontLegR2 = new Shape("frontLegR2", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.75, 5.0, 1.75], [0.0, -4.0, 0.2], [[0.0, 1.0, 0.0, 0.0, 1.25, [0.0, 1.0, -0.2]]]);
	frontLegR1.branches.push(frontLegR2);
	frontLegR3 = new Shape("frontLegR3", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFuzz,
			[1.75, 2.0, 1.75], [0.0, -3.0, 0.1], [[0.0, 1.0, 0.0, 0.0, 1.25, [0.0, 0.0, 0.0]]]);
	frontLegR2.branches.push(frontLegR3);
	
	backLegL1 = new Shape("backLegL1", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.75, 5.0, 3.0], [3.5, -2.0, -4.0], [[0.0, -1.0, 0.0, 0.0, 3.0, [0.0, 0.0, 0.0]]]);
	body2.branches.push(backLegL1);
	backLegL2 = new Shape("backLegL2", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.75, 4.0, 1.75], [0.0, -3.8, 0.5], [[0.0, -1.0, 0.0, 0.0, 0.5, [0.0, 3.8, -0.5]]]);
	backLegL1.branches.push(backLegL2);
	backLegL3 = new Shape("backLegL3", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.75, 4.0, 1.75], [0.0, -4.0, -0.1], [[0.0, -1.0, 0.0, 0.0, 0.5, [0.0, 4.0, 0.1]]]);
	backLegL2.branches.push(backLegL3);
	backLegL4 = new Shape("backLegL4", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFuzz,
			[1.75, 2.0, 2.0], [0.0, -3.0, 0.1], [[0.0, -1.0, 0.0, 0.0, 1.0, [0.0, 3.0, -0.1]]]);
	backLegL3.branches.push(backLegL4);
	
	backLegR1 = new Shape("backLegR1", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.75, 5.0, 3.0], [-3.5, -2.0, -4.0], [[0.0, -1.0, 0.0, 0.0, 3.0, [0.0, 0.0, 0.0]]]);
	body2.branches.push(backLegR1);
	backLegR2 = new Shape("backLegR2", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.75, 4.0, 1.75], [0.0, -3.8, 0.5], [[0.0, -1.0, 0.0, 0.0, 0.5, [0.0, 3.8, -0.5]]]);
	backLegR1.branches.push(backLegR2);
	backLegR3 = new Shape("backLegR3", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.75, 4.0, 1.75], [0.0, -4.0, -0.1], [[0.0, -1.0, 0.0, 0.0, 0.5, [0.0, 4.0, 0.1]]]);
	backLegR2.branches.push(backLegR3);
	backLegR4 = new Shape("backLegR4", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFuzz,
			[1.75, 2.0, 2.0], [0.0, -3.0, 0.1], [[0.0, -1.0, 0.0, 0.0, 1, [0.0, 3.0, -0.1]]]);
	backLegR3.branches.push(backLegR4);

	tail1 = new Shape("tail1", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.0, 1.0, 2.0], [0.0, 2.5, -5.0], [[0.0, 1.0, 0.0, 0.0, 1.0, [0.0, 0.0, 0.0]]]);
	body2.branches.push(tail1);
	tail2 = new Shape("tail2", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.0, 1.0, 2.0], [0.0, 0.0, -2.0], [[0.0, 1.0, 0.0, 0.0, 0.3, [0.0, 0.0, 0.0]]]);
	tail1.branches.push(tail2);
	tail3 = new Shape("tail3", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.0, 1.0, 2.0], [0.0, 0.0, -2.0], [[0.0, 1.0, 0.0, 0.0, 0.3, [0.0, 0.0, 0.0]]]);
	tail2.branches.push(tail3);
	tail4 = new Shape("tail4", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.0, 1.0, 2.0], [0.0, 0.0, -2.0], [[0.0, 1.0, 0.0, 0.0, 0.3, [0.0, 0.0, 0.0]]]);
	tail3.branches.push(tail4);
	tail5 = new Shape("tail5", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.0, 1.0, 2.0], [0.0, 0.0, -2.0], [[0.0, 1.0, 0.0, 0.0, 0.3, [0.0, 0.0, 0.0]]]);
	tail4.branches.push(tail5);
	tail6 = new Shape("tail6", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.0, 1.0, 2.0], [0.0, 0.0, -2.0], [[0.0, 1.0, 0.0, 0.0, 0.3, [0.0, 0.0, 0.0]]]);
	tail5.branches.push(tail6);
	tail7 = new Shape("tail7", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionFur,
			[1.0, 1.0, 2.0], [0.0, 0.0, -2.0], [[0.0, 1.0, 0.0, 0.0, 0.3, [0.0, 0.0, 0.0]]]);
	tail6.branches.push(tail7);
	tailTip = new Shape("tailTip", cubeVertices, cubeNormals, cubeIndices, cubeColors.lionTailTip,
			[1.75, 1.75, 2.0], [0.0, 0.0, -1.0], [[0.0, 1.0, 0.0, 0.0, 0.0, [0.0, 0.0, -1.0]]]);
	tail7.branches.push(tailTip);
}
//**************************************************************************************************************************************************************//
// Handle keyboard input.
function keyDown(e){
	switch(e.keyCode){
		// 'W', 'w' key. Move camera forward.
		case 87: case 119:
			camera.move(0.0, 0.0, MOVE_SPEED);
			break;
		// 'A', 'a' key. Move camera left.
		case 65: case 97:
			camera.move(-0.5*MOVE_SPEED, 0.0, 0.0);
			break;
		// 'S', 's' key. Move camera backward.
		case 83: case 115:
			camera.move(0.0, 0.0, -MOVE_SPEED);
			break;
		// 'D', 'd' key. Move camera right.
		case 68: case 100:
			camera.move(0.5*MOVE_SPEED, 0.0, 0.0);
			break;
		// 'E', 'e' key. Turn camera right.
		case 69: case 101:
			camera.turn(TURN_SPEED, 0);
			break;
		// 'Q', 'q' key. Turn camera left.
		case 81: case 113:
			camera.turn(-TURN_SPEED, 0);
			break;
		// 'X', 'x' key. Move camera up.
		case 88: case 120:
			camera.move(0.0, 0.5*MOVE_SPEED, 0.0);
			break;
		// 'Z', 'z' key. Move camera down.
		case 90: case 122:
			camera.move(0.0, -0.5*MOVE_SPEED, 0.0);
			break;
		// Skip redraw if nothing changed.
		default: return;
	}
	draw();
}
// Handle mouse input.
function mousePress(e){
	// Only left mouse button counts.
	if(e.buttons == 1){
		mouseLocPress[0] = e.pageX; mouseDisplace[0] = 0;
		mouseLocPress[1] = e.pageY; mouseDisplace[1] = 0;
		mouseDown = true;
	}
}
function mouseRelease(e){
	// Only left mouse button counts.
	if(e.buttons%2 != 1){
		mouseDown = false;
	}
}
function mouseMove(e){
	// Only left mouse button counts.
	if(e.buttons == 1){
		mouseDisplace[0] = e.pageX - mouseLocPress[0];
		mouseDisplace[1] = e.pageY - mouseLocPress[1];
		if(Math.abs(mouseDisplace[0]) < TURN_BUFFER){ mouseDisplace[0] = 0; }
		if(Math.abs(mouseDisplace[1]) < TURN_BUFFER){ mouseDisplace[1] = 0; }
	}
}
//**************************************************************************************************************************************************************//
// Update program logic by the given number of ticks.
function update(){
	time = Date.now();
	var ticks = (time - lastTime)*fps/1000;
	if(ticks >= 1){
		camera.update(ticks);
		if(mouseDown){ camera.turn(ticks*TURN_SPEED_MOUSE*mouseDisplace[0], ticks*TURN_SPEED_MOUSE*mouseDisplace[1]); }
		ticks %= (turnTicks*2);
		// Lion movement.
		body1.rotations[0][0] = (body1.rotations[0][0] + LION_TURN_SPEED*ticks) % 360;
		body1.vel[0] = Math.sin(body1.rotations[0][0]*RADIAN_CONVERT)*LION_SPEED;
		body1.vel[2] = Math.cos(body1.rotations[0][0]*RADIAN_CONVERT)*LION_SPEED;
		if(ticks+timer >= turnTicks){
			// Upadte all extant shapes by the given number of ticks.
			for(var i = 0; i < shapes.length; ++i){
				shapes[i].update(turnTicks-timer);
			}
			ticks -= turnTicks-timer;
			
			// Lion body animation cycle shift.
			body1.rotations[1][4] *= -1;
			body2.rotations[0][4] *= -1;
			head.rotations[0][4] *= -1;
			neck.rotations[0][4] *= -1;
			snoutBottom.rotations[0][4] *= -1;
			frontLegL1.rotations[0][4] *= -1;
			frontLegL2.rotations[0][4] *= -1;
			frontLegL3.rotations[0][4] *= -1;
			frontLegR1.rotations[0][4] *= -1;
			frontLegR2.rotations[0][4] *= -1;
			frontLegR3.rotations[0][4] *= -1;
			backLegL1.rotations[0][4] *= -1;
			backLegL2.rotations[0][4] *= -1;
			backLegL3.rotations[0][4] *= -1;
			backLegL4.rotations[0][4] *= -1;
			backLegR1.rotations[0][4] *= -1;
			backLegR2.rotations[0][4] *= -1;
			backLegR3.rotations[0][4] *= -1;
			backLegR4.rotations[0][4] *= -1;
			tail1.rotations[0][4] *= -1;
			tail2.rotations[0][4] *= -1;
			tail3.rotations[0][4] *= -1;
			tail4.rotations[0][4] *= -1;
			tail5.rotations[0][4] *= -1;
			tail6.rotations[0][4] *= -1;
			tail7.rotations[0][4] *= -1;
			
			// Upadte all extant shapes by the given number of ticks.
			for(var i = 0; i < shapes.length; ++i){
				shapes[i].update(ticks);
			}
			timer = ticks;
		}
		else{
			// Upadte all extant shapes by the given number of ticks.
			for(var i = 0; i < shapes.length; ++i){
				shapes[i].update(ticks);
			}
			timer += ticks;
		}
		draw();
		lastTime = time;
	}
	requestAnimationFrame(update);
}
// Draw current shapes to the canvas.
function draw(){
	clear();
	// Redraw all extant shapes to the canvas.
	for(var i = 0; i < shapes.length; ++i){
		brush.setIdentity();
		shapes[i].draw();
	}
}
//**************************************************************************************************************************************************************//
// Clear the canvas.
function clear(){
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}
// Write the given data to a buffer and return it, but don't assign it to any attribute variables.
function getArrayBuffer(data, num, type){
	// Create a WebGL buffer.
	var buffer = gl.createBuffer();
	if(!buffer){ console.error('Failed to create buffer object.'); return null; }
	// Write given data into the buffer object.
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	// Store extra information used to assign the object to an attribute variable later.
	buffer.num = num;
	buffer.type = type;
	buffer.len = data.length/num;
	return buffer;
}
// Create and return a WebGL texture with the given source image.
function loadTexture(source){
	var texture = gl.createTexture();
	if(!texture){ console.error('Failed to create texture object.'); return null; }
	gl.bindTexture(gl.TEXTURE_2D, texture);
	
	const level = 0;
	const internalFormat = gl.RGBA, srcFormat = gl.RGBA, srcType = gl.UNSIGNED_BYTE;
	// Until the image is loaded put a single pixel in the texture as placeholder.
	const pixel = new Uint8Array([155, 0, 0, 255]);
	gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, 1, 1, 0, srcFormat, srcType, pixel);
	
	var img = new Image();
	if(!img){ console.error('Failed to create image object.'); return null; }
	img.onload = function(){
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, img);
		
		// WebGL1 has different requirements for images with dimensions that are both powers of 2.
		if(isPowerOf2(img.width) && isPowerOf2(img.height)){
			gl.generateMipmap(gl.TEXTURE_2D);
		}
		else{
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		}
		//console.log("Loaded: "+source);
	};
	// Load in the given image.
	img.src = source;
	return texture;
}
// Return a color array for the given number of vertices, initialized as the given color.
function vertexColors(vertexNum, r, g, b, a){
	a = a || 1.0; // Default alpha channel.
	vertexNum*=4;
	var colors = new Float32Array(vertexNum);
	for(var i = 0; i < vertexNum; i+=4){
		colors[i] = r; colors[i+1] = g; colors[i+2] = b; colors[i+3] = a;
	}
	return colors;
}
// Return a vertex array for a cuboid with the given dimensions.
function cuboidVertices(xSize, ySize, zSize){
	xSize /= 2.0; ySize /= 2.0; zSize /= 2.0;
	return new Float32Array([
		 xSize, ySize, zSize, -xSize, ySize, zSize, -xSize,-ySize, zSize,  xSize,-ySize, zSize, // v0-v1-v2-v3 front
		 xSize, ySize, zSize,  xSize,-ySize, zSize,  xSize,-ySize,-zSize,  xSize, ySize,-zSize, // v0-v3-v4-v5 right
		 xSize, ySize, zSize,  xSize, ySize,-zSize, -xSize, ySize,-zSize, -xSize, ySize, zSize, // v0-v5-v6-v1 up
		-xSize, ySize, zSize, -xSize, ySize,-zSize, -xSize,-ySize,-zSize, -xSize,-ySize, zSize, // v1-v6-v7-v2 left
		-xSize,-ySize,-zSize,  xSize,-ySize,-zSize,  xSize,-ySize, zSize, -xSize,-ySize, zSize, // v7-v4-v3-v2 down
		 xSize,-ySize,-zSize, -xSize,-ySize,-zSize, -xSize, ySize,-zSize,  xSize, ySize,-zSize  // v4-v7-v6-v5 back
	]);
}
//**************************************************************************************************************************************************************//
// Converts hexadecimal color values to RGB format.
function hexToRgb(hex){
	// Use regexp to split hex. Every two digits or a-f are kept in one element of resuting array.
	const result = /^#?([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})$/i.exec(hex);
	var rgb = [];
	for(var i = 0; i < 3 && i+1 < result.length; ++i){
		rgb.push(parseInt(result[i+1], 16));
	}
	return rgb;
}
// Converts RGB color values to hexadecimal format.
function rgbToHex(r, g, b){
	return "#"+hex(r) + hex(g) + hex(b);
}
function hex(n){
	const hex = Number(n).toString(16);
	if(hex.length == 1){ return "0" + hex; }
	return hex;
}
// Returns whether or not the given number is a power of 2.
function isPowerOf2(n){ return (n & (n-1)) == 0; }